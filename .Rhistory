c(-70.915374, -33.8464671) %>%  # laguna aculeo
st_point(dim = "XYZ") %>%
st_buffer(dist = 0.1) %>%
sf_as_ee()
anio <- 2013
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-10'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 5)
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
ee_get_date_ic(disponible)
paste0(anio,'-11-10')
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-10'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 10)
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-30'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 10)
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
# extraigo la primera
escena <- df_disponible$id[1]
# defino las bandas que me interesa extraer para el NDWI
l8_bands <- ee$Image(escena)$select(c("B2", "B3", "B4", "B5"))
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = l8_bands,
region = roi$bounds(),
scale = 30)
# llamo funciones
source("R/indices.R")
NDWI(l8_img)
plot(NDWI(l8_img))
agua <- calc(NDWI(l8_img), fun = function(x) ifelse(x <= 0.2, NA, x))
agua <- raster::calc(NDWI(l8_img), fun = function(x) ifelse(x <= 0.2, NA, x))
plot(agua)
plotRGB(l8_img, r=4, g=3, b=2, stretch = "lin")
plot(agua, add = TRUE)
plotRGB(l8_img, r=3, g=2, b=1, stretch = "lin")
plot(agua, add = TRUE)
png(file=paste0("aculeo_anio",anio,".png"), width=500, height=600)
plotRGB(l8_img, r=3, g=2, b=1, stretch = "lin")
plot(agua, add = TRUE)
dev.off()
# analisis aculeo en el tiempo
analisis_aculeo <- function(anio){
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-30'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 10)
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
# extraigo la primera
escena <- df_disponible$id[1]
# defino las bandas que me interesa extraer para el NDWI
l8_bands <- ee$Image(escena)$select(c("B2", "B3", "B4", "B5"))
# B1: Aerosol, B2: Blue, B3: Green, B4: Red
# B5: NIR, B6: SWIR 1, B7: SWIR 2, B9: Cirrus
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = l8_bands,
region = roi$bounds(),
scale = 30)
agua <- calc(NDWI(l8_img), fun = function(x) ifelse(x <= 0.2, NA, x))
png(file=paste0("aculeo_anio",anio,".png"), width=500, height=600)
plotRGB(l8_img, r=3, g=2, b=1, stretch = "lin")
plot(agua, add = TRUE)
dev.off()
}
2013:2022
purrr::map(2013:2022, analisis_aculeo)
# listo funciones
funs <- lsf.str()
pacman::p_load(tidyverse, rgee, sf, raster)
purrr::map(2013:2022, analisis_aculeo)
pacman::p_load(tidyverse, rgee, sf, raster)
ee_Initialize(drive = T)
gigantemap.r(soil87.dat)
text(soil87.dat$gx,soil87.dat$gy,
as.character(soil87.dat$pHFsrf),col=4,cex=0.8)
xy.dat=expand.grid(x=1:4, y=1:4)
xy.z=1:16
xy.nb=dnearneigh(as.matrix(xy.dat), 0, 1)
xy.nb=spdep::dnearneigh(as.matrix(xy.dat), 0, 1)
str(xy.nb)
plot(xy.nb,xy.dat)
xy.W=nb2listw(xy.nb)
library(spdep)
xy.W=nb2listw(xy.nb)
moran(xy.z, xy.W, length(xy.nb), Szero(xy.W))
geary(xy.z, xy.W, length(xy.nb), length(xy.nb)-1,Szero(xy.W))
xy.W=nb2listw(xy.nb, style=“W”)
xy.W=nb2listw(xy.nb, style="W")
soil87.xy=data.frame(x=soil87.dat$gx,y=soil87.dat$gy)
autocorrelation.r(data,x,y,dist1,dist2,k=0)
pacman::p_load(sf, spdep, tmap, purrr, tidyverse)
set.seed(42)
# leemos poligonos desde archivo web
s <- readRDS(url("https://github.com/mgimond/Data/raw/gh-pages/Exercises/nhme.rds"))
# vemos nombres de las variables
names(s)
# vemos nombres de las variables
names(s)
# exploramos los valores de ingresos
s$Income
hist(s$Income, main=NULL)
boxplot(s$Income, horizontal = TRUE)
# visualizamos graficamente el ingreso
tm_shape(s) +
tm_fill(col="Income", style="quantile", n=8, palette="Greens") +
tm_legend(outside=TRUE)
# comparacion de datos reales con datos random
s$rand1 <- sample(s$Income, length(s$Income), replace = FALSE)
tm_shape(s) + tm_fill(col=c("Income", "rand1"),
style="quantile", n=8, palette="Greens", legend.show = FALSE) +
tm_facets( nrow=1)
# generamos lista de vecinos
nb <- poly2nb(s, queen=TRUE)
# generamos pesos a partir de los vecinos
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
# calculamos el indice global de moran
I <- moran(s$Income, lw, length(nb), Szero(lw))[1]
I
# calculamos el pvalue del indice
moran.test(s$Income,lw, alternative="greater")
# calculamos el moran local
lmoran <- localmoran(s$Income, lw) %>% as.data.frame()
matrix <- data.frame(value = ifelse(s$Income > mean(s$Income), "H", "L"),
correlation = ifelse(lmoran$Ii > mean(lmoran$Ii),"H","L"),
significance = lmoran$`Pr(z != E(Ii))`) %>%
mutate(cuadrant = ifelse(significance < 0.1,paste0(value,correlation),NA))
# traspasamos variable a objeto original
s$cuadrant <- matrix$cuadrant
tm_shape(s) +
tm_fill(col="cuadrant") +
tm_legend(outside=TRUE)
# visualizamos graficamente el ingreso
tm_shape(s) +
tm_fill(col="Income", style="quantile", n=8, palette="Greens") +
tm_legend(outside=TRUE)
tm_shape(s) +
tm_fill(col="NAME")
tm_shape(s) +
tm_fill(col="cuadrant") +
tm_legend(outside=TRUE)
tm_shape(s) +
tm_fill(col="NAME")+
tm_legend(outside=TRUE)
tm_shape(s) +
tm_fill(col="NAME")+
tm_legend(outside=TRUE) +
tm_borders()
tm_shape(s) +
tm_fill(col="cuadrant") +
tm_legend(outside=TRUE)
# dibujamos los cuadrantes
tm_shape(s) +
tm_fill(col="cuadrant") +
tm_legend(outside=TRUE) +
tm_borders()
pacman::p_load(sf, spdep, tmap, tidyverse)
set.seed(42)
# leemos poligonos desde archivo web
poligonos <- readRDS(url("https://github.com/mgimond/Data/raw/gh-pages/Exercises/nhme.rds"))
# vemos nombres de las variables
names(poligonos)
tm_shape(poligonos) +
tm_fill(col="NAME")+
tm_legend(outside=TRUE) +
tm_borders()
# exploramos los valores de ingresos
poligonos$Income
hist(poligonos$Income, main=NULL)
boxplot(poligonos$Income, horizontal = TRUE)
# visualizamos graficamente el ingreso
tm_shape(poligonos) +
tm_fill(col="Income", style="quantile", n=8, palette="Greens") +
tm_legend(outside=TRUE)
# comparacion de datos reales con datos random
poligonos$rand1 <- sample(poligonos$Income, length(poligonos$Income), replace = FALSE)
tm_shape(poligonos) +
tm_fill(col=c("Income", "rand1"),
style="quantile", n=8, palette="Greens", legend.show = FALSE) +
tm_facets(nrow=1)
# generamos lista de vecinos
nb <- poly2nb(poligonos, queen=TRUE)
# generamos pesos a partir de los vecinos
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
# calculamos el indice global de moran
I <- moran(poligonos$Income, lw, length(nb), Szero(lw))[1]
I
# calculamos el pvalue del indice
moran.test(poligonos$Income,lw, alternative="greater")
# calculamos el moran local
lmoran <- localmoran(poligonos$Income, lw) %>% as.data.frame()
# generamos lo cuadrantes de moran
matrix <- data.frame(value = ifelse(s$Income > mean(s$Income), "H", "L"),
correlation = ifelse(lmoran$Ii > mean(lmoran$Ii),"H","L"),
significance = lmoran$`Pr(z != E(Ii))`) %>%
mutate(cuadrant = ifelse(significance < 0.1,paste0(value,correlation),NA))
# generamos lo cuadrantes de moran
matrix <- data.frame(value = ifelse(poligonos$Income > mean(poligonos$Income), "H", "L"),
correlation = ifelse(lmoran$Ii > mean(lmoran$Ii),"H","L"),
significance = lmoran$`Pr(z != E(Ii))`) %>%
mutate(cuadrant = ifelse(significance < 0.1,paste0(value,correlation),NA))
# traspasamos variable a objeto original
poligonos$cuadrant <- matrix$cuadrant
# dibujamos los cuadrantes
tm_shape(poligonos) +
tm_fill(col="cuadrant") +
tm_legend(outside=TRUE) +
tm_borders()
poligonos$geometry
poligonos$geometry %>% st_crs()
list.files(".../")
list.files("../")
list.files("../proyectos")
list.files("../proyectos/p3.precios_viviendas")
list.files("../proyectos/p3.precios_viviendas/RM_SII_CBR")
list.files("../proyectos/p3.precios_viviendas/RM_SII_CBR2")
data <- sf::read_sf("../proyectos/p3.precios_viviendas/RM_SII_CBR2/RM_SII_CBR2.shp")
data <- sf::read_sf("../proyectos/p3.precios_viviendas/RM_SII_CBR2/RM_SII_CBR2.shp")
pacman::p_load(sf, spdep, tmap, tidyverse)
set.seed(42)
# leemos poligonos desde archivo web
poligonos <- readRDS(url("https://github.com/mgimond/Data/raw/gh-pages/Exercises/nhme.rds"))
View(poligonos)
# vemos nombres de las variables
names(poligonos)
tm_shape(poligonos) +
tm_fill(col="NAME")+
tm_legend(outside=TRUE) +
tm_borders()
# exploramos los valores de ingresos
poligonos$Income
hist(poligonos$Income, main=NULL)
boxplot(poligonos$Income, horizontal = TRUE)
# visualizamos graficamente el ingreso
tm_shape(poligonos) +
tm_fill(col="Income", style="quantile", n=8, palette="Greens") +
tm_legend(outside=TRUE)
# visualizamos graficamente el ingreso
tm_shape(poligonos) +
tm_fill(col="Income", style="quantile", n=8, palette="Greens") +
tm_legend(outside=TRUE) +
tm_borders()
# comparacion de datos reales con datos random
poligonos$rand1 <- sample(poligonos$Income, length(poligonos$Income), replace = FALSE)
tm_shape(poligonos) +
tm_fill(col=c("Income", "rand1"),
style="quantile", n=8, palette="Greens", legend.show = FALSE) +
tm_facets(nrow=1)
# generamos lista de vecinos
nb <- poly2nb(poligonos, queen=TRUE)
# generamos pesos a partir de los vecinos
lw <- nb2listw(nb, style="W", zero.policy=TRUE)
# calculamos el indice global de moran
I <- moran(poligonos$Income, lw, length(nb), Szero(lw))[1]
I
# calculamos el indice global de moran
I <- moran(poligonos$Income, lw, length(nb), Szero(lw))
I
# calculamos el pvalue del indice
moran.test(poligonos$Income,lw, alternative="greater")
# calculamos el moran local
lmoran <- localmoran(poligonos$Income, lw) %>% as.data.frame()
View(lmoran)
# generamos lo cuadrantes de moran
matrix <- data.frame(value = ifelse(poligonos$Income > mean(poligonos$Income), "H", "L"),
correlation = ifelse(lmoran$Ii > mean(lmoran$Ii),"H","L"),
significance = lmoran$`Pr(z != E(Ii))`) %>%
mutate(cuadrant = ifelse(significance < 0.1,paste0(value,correlation),NA))
View(matrix)
# traspasamos variable a objeto original
poligonos$cuadrant <- matrix$cuadrant
# dibujamos los cuadrantes
tm_shape(poligonos) +
tm_fill(col="cuadrant") +
tm_legend(outside=TRUE) +
tm_borders()
# invocamos las librerias
pacman::p_load(sf, tidyverse, spdep)
options(scipen = 999)
# cargamos los datos de prueba que vienen en la libreria sf
nc <- st_read(system.file("shape/nc.shp", package="sf"))
# extraemos las variables numericas que vamos a estudiar
# tasa de natalidad
# tasa de natalidad no caucasica
# tasa de mortalidad al nacer (sudden infant death)
nc_vars <- nc %>% select(BIR74, NWBIR74, SID74) %>% st_drop_geometry()
# exploramos la distribucion de las variables
hist(nc_vars$BIR74)
hist(nc_vars$NWBIR74)
hist(nc_vars$SID74)
# usamos el metodo mas sencillo, kmeans, para agrupar los condados en 10 clusters segun las variables
clusters_k <- kmeans(nc_vars, 10)
# creamos la variable cluster en el conjunto nc
nc$cluster_kmeans <- as.factor(clusters_k$cluster)
# visualizamos
ggplot(nc) +
geom_sf(aes(fill = cluster_kmeans))
clusters_k$betweenss / mean(dist(nc_vars))
# exploramos la escala de las variables
summary(nc_vars)
# repetimos el proceso escalando las variables como x-mu/sd
scaled_vars <- scale(nc_vars)
summary(scaled_vars)
# volvemos a clusterizar con las variables escaladas
clusters_k_sc <- kmeans(scaled_vars, 10)
nc$cluster_kmeans_sc <- as.factor(clusters_k_sc$cluster)
ggplot(nc) +
geom_sf(aes(fill = cluster_kmeans_sc))
clusters_k_sc$betweenss / mean(dist(scaled_vars))
# aun se ve ruidoso
# analizamos las correlaciones entre las variables
cor(nc_vars)
# creamos la variable de tasas de muerte por tipo de natalidad
nc_vars_rate <-
nc_vars %>%
mutate(SID_BIR = SID74 / BIR74,
SID_NW = SID74 / NWBIR74)
# volvemos a analizar las correlaciones
cor(nc_vars_rate)
# seleccionamos las variables sin correlacion relevante
nc_vars_rate <-
nc_vars_rate %>%
select(BIR74, SID_BIR, SID_NW)
# vemos que la escala sigue siendo relevante
summary(nc_vars_rate)
# escalamos las variables nuevas
scaled_vars_rate <- scale(nc_vars_rate)
summary(scaled_vars_rate)
# volvemos a calcular el kmeans con datos transformados
clusters_k_sc_rate <- kmeans(scaled_vars_rate, 10)
nc$cluster_kmeans_sc_rate <- as.factor(clusters_k_sc_rate$cluster)
# volvemos a analizar las correlaciones
cor(nc_vars_rate)
cor(nc_vars_rate)
# vemos que la escala sigue siendo relevante
summary(nc_vars_rate)
# escalamos las variables nuevas
scaled_vars_rate <- scale(nc_vars_rate)
summary(scaled_vars_rate)
cor(scaled_vars_rate)
# volvemos a calcular el kmeans con datos transformados
clusters_k_sc_rate <- kmeans(scaled_vars_rate, 10)
nc$cluster_kmeans_sc_rate <- as.factor(clusters_k_sc_rate$cluster)
ggplot(nc) +
geom_sf(aes(fill = cluster_kmeans_sc_rate))
clusters_k_sc_rate$betweenss / mean(dist(scaled_vars_rate))
# calculamos distancia de atributos en base a las variables escaladas
dist_sc_rate <- dist(scaled_vars_rate)
# generamos modelo jerarquico
hclust <- hclust(dist_sc_rate)
plot(hclust)
# cortamos modelo en 10 clusters
clusters_hier <- factor(cutree(hclust, k = 10))
ggplot(nc) +
geom_sf(aes(fill = clusters_hier))
# calculamos la matriz de vecindades
matriz_vecindad <- poly2nb(nc)
# viene como una lista, asi que la transformamos en una matriz
matriz_vec <- map(1:nrow(nc), function(i) as.numeric(1:nrow(nc) %in% matriz_vecindad[[i]])) %>%
unlist() %>%
matrix(nrow=nrow(nc))
# la matriz de atributos tambien viene como un objeto de distancia, la pasamos a matriz
matriz_atr <- dist_sc_rate %>% as.matrix()
# ahora construimos una matriz de vecindad-atributo
# donde la matriz de vecindad es 0 (no vecino), le asignamos un valor muy grande (10000), de lo contrario,
# mantiene el valor de distancia de atributos
matriz_atr_vec <- (1-matriz_vec)*10000 + matriz_vec*matriz_atr
# pasamos la matriz a objeto distancia (lo que recibe el hclust)
dist_atr_vec <- matriz_atr_vec %>% as.dist()
# ejecutamos el hclust con esta matriz de vecindad-atributo
hclust2 <- hclust(dist_atr_vec)
plot(hclust2)
# veamos como queda el corte con 10 clusters
clusters_hier2 <- factor(cutree(hclust2, k = 10))
ggplot(nc) +
geom_sf(aes(fill = clusters_hier2))
# probamos otro metodo de distancia jerarquica
hclust3 <- hclust(dist_atr_vec, method = "average")
plot(hclust3)
# el arbol esta mas distribuido
clusters_hier3 <- factor(cutree(hclust3, k = 10))
ggplot(nc) +
geom_sf(aes(fill = clusters_hier3))
# probamos otro metodo de distancia jerarquica
hclust4 <- hclust(dist_atr_vec, method = "single")
plot(hclust4)
clusters_hier4 <- factor(cutree(hclust4, k = 10))
ggplot(nc) +
geom_sf(aes(fill = clusters_hier4))
# probamos un metodo mas de distancia jerarquica
hclust5 <- hclust(dist_atr_vec, method = "ward.D")
plot(hclust5)
clusters_hier5 <- factor(cutree(hclust5, k = 10))
ggplot(nc) +
geom_sf(aes(fill = clusters_hier5))
ggplot(mtcars, aes(factor(cyl), mpg)) +
geom_boxplot() +
# Here comes the gganimate code
transition_states(
gear,
transition_length = 2,
state_length = 1
) +
enter_fade() +
exit_shrink() +
ease_aes('sine-in-out')
library(gganimate)
ggplot(mtcars, aes(factor(cyl), mpg)) +
geom_boxplot() +
# Here comes the gganimate code
transition_states(
gear,
transition_length = 2,
state_length = 1
) +
enter_fade() +
exit_shrink() +
ease_aes('sine-in-out')
clusters_hier5 <- factor(cutree(hclust5, k = 10))
ggplot(nc) +
geom_sf(aes(fill = clusters_hier5))
aa <- map_dfr(1:100, function(i) nc %>% mutate(i = factor(cutree(hclust5, k = i))))
animate <- map_dfr(1:100, function(i) nc %>% mutate(i = factor(cutree(hclust5, k = i))))
animate <- map_dfr(1:100, function(i) nc %>% mutate(k = factor(cutree(hclust5, k = i))))
animate <- map_dfr(1:100, function(i) nc %>% mutate(k = factor(cutree(hclust5, k = i)),
frame = i))
animate$frame %>% table()
ggplot(nc) +
geom_sf(aes(fill = k))
ggplot(animate) +
geom_sf(aes(fill = k))
ggplot(animate) +
geom_sf(aes(fill = k)) +
# Here comes the gganimate code
transition_states(
frame,
transition_length = 2,
state_length = 1
) +
enter_fade() +
exit_shrink() +
ease_aes('sine-in-out')
? transition_states
ggplot(animate) +
geom_sf(aes(fill = k)) +
# aca viene el codigo para animar
transition_states(frame)
ggplot(animate) +
geom_sf(aes(fill = k)) +
# aca viene el codigo para animar
transition_time(frame)
animate <- map_dfr((1:10)*10, function(i) nc %>% mutate(k = factor(cutree(hclust5, k = i)),
frame = i))
ggplot(animate) +
geom_sf(aes(fill = k)) +
# aca viene el codigo para animar
transition_time(frame)
i = 1
paste0("Figuras/cluster",i,".png")
nc <- nc %>% mutate(k = factor(cutree(hclust5, k = i)),
frame = i)
ggplot(nc) +
geom_sf(aes(fill = k))
nc <- nc %>% mutate(k = factor(cutree(hclust5, k = i)))
ggplot(nc) +
geom_sf(aes(fill = k))
ggsave(paste0("Figuras/cluster",i,".png"))
for(i in 1:100) {
nc <- nc %>% mutate(k = factor(cutree(hclust5, k = i)))
ggplot(nc) +
geom_sf(aes(fill = k))
ggsave(paste0("Figuras/cluster",i,".png"))
}
system(paste0("ffmpeg -framerate 60 -i Figuras/cluster%d.png -pix_fmt yuv420p clusters.mp4"))
ggplot(nc) +
geom_sf(aes(fill = k)) +
theme_void()
ggplot(nc) +
geom_sf(aes(fill = k)) +
theme(legend.position = "none")
for(i in 1:100) {
nc <- nc %>% mutate(k = factor(cutree(hclust5, k = i)))
ggplot(nc) +
geom_sf(aes(fill = k)) +
theme(legend.position = "none")
ggsave(paste0("Figuras/cluster",i,".png"))
}
for(i in 1:100) {
nc <- nc %>% mutate(k = factor(cutree(hclust5, k = 101-i)))
ggplot(nc) +
geom_sf(aes(fill = k)) +
theme(legend.position = "none")
ggsave(paste0("Figuras/cluster",i,".png"))
}
system("ffmpeg -framerate 60 -i Figuras/cluster%d.png -pix_fmt yuv420p Figuras/clusters.mp4")
filenames <- paste0("Figuras/cluster",1:100,".png")
m <- magick::image_read(filenames[1])
for (i in 2:100)
m <- c(m, magick::image_read(filenames[i]))
m <- magick::image_animate(m, fps = 10, loop = 1, dispose = "previous")
magick::image_write(m, "movie.gif")
? magick::image_write
filenames
