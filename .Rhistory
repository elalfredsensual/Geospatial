ncg
# Unary operations
b0 <- st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 <- st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(0,-1), c(-1,-1))))
st_is_valid(st_sfc(b0,b1))
plot(b0)
plot(b1)
plot(b1)
s <- st_sfc(st_linestring(rbind(c(0,0), c(1,1))),
st_linestring(rbind(c(0,0), c(1,1),c(0,1),c(1,0))))
st_is_simple(s)
plot(s)
plot(st_linestring(rbind(c(0,0), c(1,1)))
)
plot(st_linestring(rbind(c(0,0), c(1,1))))
plot(st_linestring(rbind(c(0,0), c(1,1),c(0,1),c(1,0))))
st_area(x)
# operaciones geometricas
b0 = st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 = b0 + 2
b2 = b0 + c(-0.2, 2)
x = st_sfc(b0, b1, b2)
# operaciones geometricas
b0 <- st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 <- b0 + 2
b2 <- b0 + c(-0.2, 2)
x <- st_sfc(b0, b1, b2)
a0 <- b0 * 0.8
# operaciones geometricas
b0 <- st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 <- b0 + 2
b2 <- b0 + c(-0.2, 2)
x <- st_sfc(b0, b1, b2)
a0 <- b0 * 0.8
a1 <- a0 * 0.5 + c(2, 0.7)
a2 <- a0 + 1
a3 <- b0 * 0.5 + c(2, -0.5)
y <- st_sfc(a0,a1,a2,a3)
plot(x, border = 'red')
plot(y, border = 'green', add = TRUE)
b0 <- st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 <- b0 + 2
b2 <- b0 + c(-0.2, 2)
x <- st_sfc(b0, b1, b2)
a0 <- b0 * 0.8
a1 <- a0 * 0.5 + c(2, 0.7)
a2 <- a0 + 1
a3 <- b0 * 0.5 + c(2, -0.5)
y <- st_sfc(a0,a1,a2,a3)
plot(x, border = 'red')
plot(y, border = 'green', add = TRUE)
st_area(x)
# calculo de area y longitud
st_area(x)
st_area(st_sfc(st_point(c(0,0))))
st_length(st_sfc(st_linestring(rbind(c(0,0),c(1,1),c(1,2))), st_linestring(rbind(c(0,0),c(1,0)))))
st_length(st_sfc(st_linestring(rbind(c(0,0),c(1,1),c(1,2))), st_linestring(rbind(c(0,0),c(1,0)))))
st_length(st_sfc(st_multilinestring(list(rbind(c(0,0),c(1,1),c(1,2))),rbind(c(0,0),c(1,0))))) # ignores 2nd part!
st_length(st_sfc(st_multilinestring(list(rbind(c(0,0),c(1,1),c(1,2))),rbind(c(0,0),c(1,0)))))
st_length(st_sfc(st_linestring(rbind(c(0,0),c(1,1),c(1,2))), st_linestring(rbind(c(0,0),c(1,0)))))
# Binary operations: distance and relate
st_distance(x,y)
st_relate(x,y)
# operaciones binarias
st_distance(x,y)
st_relate(x,y)
# comparaciones
st_intersects(x,y)
st_intersects(x, x, sparse = FALSE)
st_intersects(x, y, sparse = FALSE)
st_covers(x, y, sparse = FALSE)
st_covered_by(x, y, sparse = FALSE)
? st_covered_by
st_covers(x, y, sparse = FALSE)
st_covered_by(x, y, sparse = FALSE)
st_covered_by(y, y, sparse = FALSE)
st_covers(x, y, sparse = FALSE)
st_equals_exact(x, y,0.001, sparse = FALSE)
# operaciones binarias
u <- st_union(x)
plot(u)
# operaciones binarias
plot(st_union(x))
plot(st_buffer(x, 0.2))
plot(st_buffer(x, -0.2), add = TRUE)
plot(st_boundary(x))
# operaciones binarias
plot(st_union(x))
plot(st_buffer(x, 0.2))
plot(st_buffer(x, -0.2))
plot(st_boundary(x))
plot(st_convex_hull(x))
plot(st_convex_hull(u))
# operaciones binarias
u <- st_union(x)
# operaciones binarias
(u <- st_union(x))
plot(u)
(b <- st_buffer(x, 0.2))
plot(b)
plot(st_buffer(x, -0.2))
plot(st_boundary(x))
plot(st_boundary(u))
plot(st_convex_hull(x))
plot(st_convex_hull(u))
plot(x)
plot(st_centroid(x), add = TRUE, col = 'red')
plot(x)
plot(st_centroid(u), add = TRUE, col = 'red')
plot(u)
plot(st_centroid(u), add = TRUE, col = 'red')
plot(x)
plot(y, add = TRUE)
plot(st_intersection(st_union(x),st_union(y)), add = TRUE, col = 'red')
plot(x, col = '#ff333388');
plot(y, add=TRUE, col='#33ff3388')
title("x: red, y: green")
plot(x, border = 'grey')
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(x, col = '#ff333388');
plot(y, add=TRUE, col='#33ff3388')
title("x: red, y: green")
plot(x, border = 'grey')
plot(st_difference(st_union(x),st_union(y)), col = 'lightblue', add = TRUE)
title("difference(x,y)")
plot(x, border = 'grey')
plot(st_difference(st_union(y),st_union(x)), col = 'lightblue', add = TRUE)
title("difference(y,x)")
plot(x, border = 'grey')
plot(st_sym_difference(st_union(y),st_union(x)), col = 'lightblue', add = TRUE)
title("sym_difference(x,y)")
par(mfrow=c(1,3),mar=c(1,1,0,0))
pts = rbind(c(0,0),c(1,0),c(2,1),c(3,1))
ls = st_linestring(pts)
plot(ls)
points(pts)
ls.seg = st_segmentize(ls, 0.3)
plot(ls.seg)
pts = ls.seg
points(pts)
pol = st_polygon(list(rbind(c(0,0),c(1,0),c(1,1),c(0,1),c(0,0))))
pol.seg = st_segmentize(pol, 0.3)
plot(pol.seg, col = 'grey')
points(pol.seg[[1]])
# interseccin
plot(x)
plot(y, add = TRUE)
plot(st_intersection(st_union(x),st_union(y)), add = TRUE, col = 'red')
plot(u)
#
plot(x)
plot(st_centroid(x), add = TRUE, col = 'red')
plot(u)
plot(st_centroid(u), add = TRUE, col = 'red')
st_inscribed_circle(x)
plot(st_inscribed_circle(x))
plot(st_inscribed_circle(u))
pacman::p_load(sf, tidyverse)
st_point(c(1,1))
# puntos
st_point(c(1,1)) %>% st_cast("MULTIPOINT")
st_multipoint(rbind(c(1,1))) %>% st_cast("POINT")
st_multipoint(rbind(c(1,1)))
st_multipoint(rbind(c(1,1))) %>% st_cast("POINT")
st_multipoint(rbind(c(1,1),c(2,2)))
st_multipoint(rbind(c(1,1),c(2,2))) %>% st_cast("POINT")
st_geometrycollection(list(st_point(c(1,1))))
st_geometrycollection(list(st_point(c(1,1)))) %>% st_cast("POINT")
# lineas
ls <- st_linestring(rbind(c(0,0),c(1,1),c(2,1)))
mls1 <- st_multilinestring(list(rbind(c(2,2),c(1,3)), rbind(c(0,0),c(1,1),c(2,1))))
mls2 <- st_multilinestring(list(rbind(c(4,4),c(4,3)), rbind(c(2,2),c(2,1),c(3,1))))
(sfc <- st_sfc(ls,mls1,mls2))
st_cast(sfc, "MULTILINESTRING")
# poligonos
shp <- system.file("shape/nc.shp", package="sf")
class(st_geometry(st_read(shp, quiet = TRUE)))
class(st_geometry(st_read(shp, quiet = TRUE, type = 3)))
class(st_geometry(st_read(shp, quiet = TRUE, type = 1)))
? st_read
# multigeometrias
gc1 <- st_geometrycollection(list(st_linestring(rbind(c(0,0),c(1,1),c(2,1)))))
gc2 <- st_geometrycollection(list(st_multilinestring(list(rbind(c(2,2),c(1,3)), rbind(c(0,0),c(1,1),c(2,1))))))
gc3 <- st_geometrycollection(list(st_multilinestring(list(rbind(c(4,4),c(4,3)), rbind(c(2,2),c(2,1),c(3,1))))))
(sfc <- st_sfc(gc1,gc2,gc3))
# tranformaciones algebraicas
(p <- st_point(c(0,2)))
p + 1 # sumo el mismo valor a ambas coordenadas
p + c(1,2) #sumo diferentes valores por coordenadas
p + p # sumo 2 veces el mismo vector
p * p # multiplico cada valor por si mismo
# creo una funcion de rotacion
rot <- function(a) matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2)
p * rot(pi/4)
p * rot(pi/2)
p * rot(pi)
p * rot(2*pi)
# centroides
nc <- st_read(shp)
ncg <- st_geometry(nc)
plot(ncg, border = 'grey')
st_centroid(ncg)
cntrd <- st_centroid(ncg)
plot(cntrd, col = 'red', add = TRUE, cex = .5)
ncg2 <- (ncg - cntrd) * rot(pi/2) * .75 + cntrd
plot(ncg2, add = TRUE)
# operaciones simples
b0 <- st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 <- st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(0,-1), c(-1,-1))))
st_is_valid(st_sfc(b0,b1))
plot(b0)
plot(b1)
s <- st_sfc(st_linestring(rbind(c(0,0), c(1,1))),
st_linestring(rbind(c(0,0), c(1,1),c(0,1),c(1,0))))
st_is_simple(s)
b0 <- st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
plot(b0)
b1 <- b0 + 2
b2 <- b0 + c(-0.2, 2)
x <- st_sfc(b0, b1, b2)
a0 <- b0 * 0.8
a1 <- a0 * 0.5 + c(2, 0.7)
a2 <- a0 + 1
a3 <- b0 * 0.5 + c(2, -0.5)
y <- st_sfc(a0,a1,a2,a3)
plot(x, border = 'red')
plot(y, border = 'green', add = TRUE)
# calculo de area y longitud
st_area(x)
st_area(st_sfc(st_point(c(0,0))))
st_length(st_sfc(st_linestring(rbind(c(0,0),c(1,1),c(1,2))), st_linestring(rbind(c(0,0),c(1,0)))))
# calculo de distancias
st_distance(x,y)
st_relate(x,y)
# comparaciones
st_intersects(x,y)
st_intersects(x, x, sparse = FALSE)
st_intersects(x, y, sparse = FALSE)
st_intersects(x, x, sparse = FALSE)
st_intersects(x, y, sparse = FALSE)
st_disjoint(x, y, sparse = FALSE)
st_touches(x, y, sparse = FALSE)
st_crosses(s, s, sparse = FALSE)
st_within(x, y, sparse = FALSE)
st_contains(x, y, sparse = FALSE)
st_overlaps(x, y, sparse = FALSE)
st_equals(x, y, sparse = FALSE)
st_equals_exact(x, y, 0.001, sparse = FALSE)
st_covers(x, y, sparse = FALSE)
st_covered_by(x, y, sparse = FALSE)
st_covered_by(y, y, sparse = FALSE)
aa <- st_covered_by(y, y, sparse = FALSE)
View(aa)
rm(aa)
x
# operaciones binarias
(u <- st_union(x))
plot(u)
#
plot(x)
plot(st_centroid(x), add = TRUE, col = 'red')
plot(u)
plot(st_centroid(u), add = TRUE, col = 'red')
# buffer
(b <- st_buffer(x, 0.2))
plot(b)
# buffer
(b <- st_buffer(x, 0.7))
plot(b)
plot(x)
plot(b, col="red", add=TRUE)
plot(x)
plot(b, col="red")
plot(x, add=TRUE)
# buffer
(b <- st_buffer(x, 0.2))
plot(b, col="red")
plot(x, add=TRUE)
# buffer
(b <- st_buffer(x, 100))
plot(b, col="red")
plot(x, add=TRUE)
# buffer
(b <- st_buffer(x, 0.2))
plot(b, col="red")
plot(x, add=TRUE)
plot(st_buffer(x, -0.2))
# frontera
plot(st_boundary(x))
plot(st_boundary(u))
# casco convexo
plot(st_convex_hull(x))
plot(st_convex_hull(u))
# circunferencia inscrita
plot(st_inscribed_circle(x))
plot(st_inscribed_circle(u))
plot(st_convex_hull(u), add=TRUE)
plot(st_convex_hull(x), add=TRUE)
# circunferencia inscrita
plot(st_inscribed_circle(x))
plot(st_inscribed_circle(u))
# interseccion
plot(x)
plot(y, add = TRUE)
plot(st_intersection(st_union(x),st_union(y)), add = TRUE, col = 'red')
# differencias
par(mfrow=c(2,2), mar = c(0,0,1,0))
# differencias
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(x, col = '#ff333388');
plot(y, add=TRUE, col='#33ff3388')
title("x: red, y: green")
plot(x, border = 'grey')
plot(st_difference(st_union(x),st_union(y)), col = 'lightblue', add = TRUE)
title("difference(x,y)")
plot(x, border = 'grey')
plot(st_difference(st_union(y),st_union(x)), col = 'lightblue', add = TRUE)
title("difference(y,x)")
plot(x, border = 'grey')
plot(st_sym_difference(st_union(y),st_union(x)), col = 'lightblue', add = TRUE)
title("sym_difference(x,y)")
? pacman::p_load
pacman::p_load(sf, tidyverse, sfnetworks, openrouteservice, terra, leaflet)
# cargamos un shape de poligonos
nc <- st_read(system.file("shape/nc.shp", package="sf"))
# extramos la geometria
nc_g <- st_geometry(nc)
# dibujamos la primera geometria
plot(nc_g[1], lwd = 3)
plot(st_simplify(nc_g[1], dTolerance = 1e3), add=TRUE, border="red") # la simplificacion con umbral de 1000m
plot(st_simplify(nc_g[1], dTolerance = 5e3), add=TRUE, border="green") # 5000m
# generamos poligono
pol <- st_polygon(list(rbind(c(0,0),c(1,0),c(1,1),c(0,1),c(0,0))))
# segmentamos poligono con parametro de distancia 0.3
pol.seg <- st_segmentize(pol, 0.3)
# dibujamos resultados
plot(pol.seg, col = 'grey')
points(pol.seg[[1]])
# generamos linea
ls <- st_linestring(rbind(c(0,0),c(1,0),c(2,1),c(3,1)))
# segmentamos lineas
ls.seg <- st_segmentize(ls, 0.3)
# dibujamos resultados
plot(ls)
points(ls.seg)
# creamos lineas
lines <- st_multilinestring(list(
cbind(c(0, 1), c(1, 1.05)),
cbind(c(0, 1), c(0, -.05)),
cbind(c(1, .95, 1), c(1.05, .5, -.05))
))
# visualizamos
plot(lines, lwd=2, col='blue')
# creamos polinono
poly <- st_polygon(list(cbind(c(0, 0, 1, 1, 0), c(0, 1, 1, 0, 0))))
plot(poly, add=TRUE, pch = 2)
# acoplamos poligono a lineas
snapped <- st_snap(poly, lines, tolerance=.1)
# agregamos al grafico
plot(snapped, col='red', add=TRUE, alpha=0.5)
# creamos multilinea
mls <- st_multilinestring(list(matrix(c(0,0,0,1,1,1,0,0), 4 ,2,byrow=TRUE)))
# poligonizamos
st_polygonize(st_sfc(mls))
# visualizamos
plot(mls)
plot(st_polygonize(st_sfc(mls)), add=TRUE)
# triangulizamos la primera geometria del shape
triang <- st_triangulate(nc_g[1])
# dibujamos forma original y triangulos encima
plot(nc_g[1], col="black")
plot(triang, col=NULL, border="white", add=TRUE)
# creamos polignos de voronoi sobre la misma geometria de antes
voron <- st_voronoi(nc_g[1])
# repetimos el grafico
plot(nc_g[1], col="black")
plot(voron, col=NULL, border="white", add=TRUE)
# obtenemos red de roxel, disponible en la libreria
net <- as_sfnetwork(roxel, directed = FALSE)
plot(net)
# utilizamos funcion para encontrar ruta entre nodos 1 y 9
path <- igraph::shortest_paths(net, 1, 9)$vpath[[1]]
# extraemos del objeto net los puntos del camino mas corto
path_net <- st_geometry(net)[path %>% as.numeric()] %>%
st_as_sf("POINT")
# agregamos puntos al mapa, de color rojo
plot(path_net, add=TRUE, col="red", lwd  = 8)
# creamos funcion con impedancia segun regla de Tobler
tobler_impedance <- function(slope){
w <- 6*exp(-3.5*abs(slope +0.05))
return(w)
}
# cargamos ruta de cerro el plomo
plomo <- read_rds("data/ruta_plomo.rds")
# calculamos las metricas de distancia, diferencia de altitud de cada medicion
# calculamos la velocidad segun impedancia de toble, y luego la duracion
plomo <- plomo %>%
mutate(slope = pmin(0.4, pmax(-0.4,tan(grade_smooth/360*2*pi))),
tobler_speed = tobler_impedance(slope),
delta_distance = c(0,diff(distance)),
duration = (delta_distance)/tobler_speed) %>%
filter(delta_distance > 0)
# calculamos la diferencia entre medicion real y calculada
sum(plomo$duration)
max(plomo$time) / 3600
# para utilizar la libreria debemos obtener una llave a su API
# esta es mi llave, deberian obtener las suyas en la pagina para que no colapse
# https://openrouteservice.org/dev/#/signup
ors_api_key("5b3ce3597851110001cf6248db68c78edc7b41538810b09141f8cb60")
remotes::install_github("GIScience/openrouteservice-r")
remotes::install_github("GIScience/openrouteservice-r")
pacman::p_load(sf, tidyverse, sfnetworks, openrouteservice, terra, leaflet)
# cargamos ruta de cerro el plomo
plomo <- read_rds("data/ruta_plomo.rds")
# calculamos las metricas de distancia, diferencia de altitud de cada medicion
# calculamos la velocidad segun impedancia de toble, y luego la duracion
plomo <- plomo %>%
mutate(slope = pmin(0.4, pmax(-0.4,tan(grade_smooth/360*2*pi))),
tobler_speed = tobler_impedance(slope),
delta_distance = c(0,diff(distance)),
duration = (delta_distance)/tobler_speed) %>%
filter(delta_distance > 0)
# calculamos la diferencia entre medicion real y calculada
sum(plomo$duration)
max(plomo$time) / 3600
# para utilizar la libreria debemos obtener una llave a su API
# esta es mi llave, deberian obtener las suyas en la pagina para que no colapse
# https://openrouteservice.org/dev/#/signup
ors_api_key("5b3ce3597851110001cf6248db68c78edc7b41538810b09141f8cb60")
# utilizamos la funcion isochrones para calcular las isocronas de la coordenada a 20 minutos
drivetime <- ors_isochrones(
# definimos punto de inicio
locations = c(-70.51, -33.49),
# usamos perfil de ciclista
profile = "cycling-mountain",
# 20 minutos
range = 20*60,
# devuelve un objeto sf
output = "sf"
)
# calculamos la diferencia entre medicion real y calculada
sum(plomo$duration)
max(plomo$time) / 3600
# para utilizar la libreria debemos obtener una llave a su API
# esta es mi llave, deberian obtener las suyas en la pagina para que no colapse
# https://openrouteservice.org/dev/#/signup
ors_api_key("5b3ce3597851110001cf6248db68c78edc7b41538810b09141f8cb60")
# utilizamos la funcion isochrones para calcular las isocronas de la coordenada a 20 minutos
drivetime <- ors_isochrones(
# definimos punto de inicio
locations = c(-70.51, -33.49),
# usamos perfil de ciclista
profile = "cycling-mountain",
# 20 minutos
range = 20*60,
# devuelve un objeto sf
output = "sf"
)
# creamos mapa dinamico para visualizarlo
leaflet() %>%
addProviderTiles("OpenStreetMap") %>%
addAwesomeMarkers(
lat = -33.49,
lng = -70.51,
label = "UAI") %>%
addPolygons(data = drivetime)
# identificamos un objeto raster de la libreria terra
f <- system.file("ex/elev.tif", package="terra")
# lo almacenamos como raster
r <- rast(f)
# exploramos su resolucion
res(r)
# disminuimos la resolucion utilizando diferentes funciones de agregacion
rmean <- aggregate(r, c(4,5), fun=mean)
rmin <- aggregate(r, c(4,5), fun=min)
rmax <- aggregate(r, c(4,5), fun=max)
# validamos resolucion
res(rmin)
# graficamos original y 3 agregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(rmean)
plot(rmin)
plot(rmax)
# creamos un raster vacio en funcion de r
x <- rast(r)
# definimos su resolucion
res(x) <- c(0.0001, 0.0001)
# hacemos un mapeo de los datos de menor resolucion a mayor utilizando diferentes metodos
xbilin <- resample(r, x, method="bilinear")
xcubic <- resample(r, x, method="cubic")
xcubicspline <- resample(r, x, method="cubicspline")
# graficamos el original y los 3 desagregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(xbilin)
plot(xcubic)
plot(xcubic)
x <- rast(r)
# definimos su resolucion
res(x) <- c(0.0005, 0.0005)
# hacemos un mapeo de los datos de menor resolucion a mayor utilizando diferentes metodos
xbilin <- resample(r, x, method="bilinear")
xcubic <- resample(r, x, method="cubic")
xcubicspline <- resample(r, x, method="cubicspline")
# graficamos el original y los 3 desagregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(xbilin)
plot(xcubic)
plot(xcubic)
pacman::p_load_gh("GIScience/openrouteservice-r")
