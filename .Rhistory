duration = (delta_distance)/tobler_speed) %>%
filter(delta_distance > 0)
# calculamos la diferencia entre medicion real y calculada
sum(plomo$duration)
max(plomo$time) / 3600
# para utilizar la libreria debemos obtener una llave a su API
# esta es mi llave, deberian obtener las suyas en la pagina para que no colapse
# https://openrouteservice.org/dev/#/signup
ors_api_key("5b3ce3597851110001cf6248db68c78edc7b41538810b09141f8cb60")
# utilizamos la funcion isochrones para calcular las isocronas de la coordenada a 20 minutos
drivetime <- ors_isochrones(
# definimos punto de inicio
locations = c(-70.51, -33.49),
# usamos perfil de ciclista
profile = "cycling-mountain",
# 20 minutos
range = 20*60,
# devuelve un objeto sf
output = "sf"
)
# calculamos la diferencia entre medicion real y calculada
sum(plomo$duration)
max(plomo$time) / 3600
# para utilizar la libreria debemos obtener una llave a su API
# esta es mi llave, deberian obtener las suyas en la pagina para que no colapse
# https://openrouteservice.org/dev/#/signup
ors_api_key("5b3ce3597851110001cf6248db68c78edc7b41538810b09141f8cb60")
# utilizamos la funcion isochrones para calcular las isocronas de la coordenada a 20 minutos
drivetime <- ors_isochrones(
# definimos punto de inicio
locations = c(-70.51, -33.49),
# usamos perfil de ciclista
profile = "cycling-mountain",
# 20 minutos
range = 20*60,
# devuelve un objeto sf
output = "sf"
)
# creamos mapa dinamico para visualizarlo
leaflet() %>%
addProviderTiles("OpenStreetMap") %>%
addAwesomeMarkers(
lat = -33.49,
lng = -70.51,
label = "UAI") %>%
addPolygons(data = drivetime)
# identificamos un objeto raster de la libreria terra
f <- system.file("ex/elev.tif", package="terra")
# lo almacenamos como raster
r <- rast(f)
# exploramos su resolucion
res(r)
# disminuimos la resolucion utilizando diferentes funciones de agregacion
rmean <- aggregate(r, c(4,5), fun=mean)
rmin <- aggregate(r, c(4,5), fun=min)
rmax <- aggregate(r, c(4,5), fun=max)
# validamos resolucion
res(rmin)
# graficamos original y 3 agregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(rmean)
plot(rmin)
plot(rmax)
# creamos un raster vacio en funcion de r
x <- rast(r)
# definimos su resolucion
res(x) <- c(0.0001, 0.0001)
# hacemos un mapeo de los datos de menor resolucion a mayor utilizando diferentes metodos
xbilin <- resample(r, x, method="bilinear")
xcubic <- resample(r, x, method="cubic")
xcubicspline <- resample(r, x, method="cubicspline")
# graficamos el original y los 3 desagregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(xbilin)
plot(xcubic)
plot(xcubic)
x <- rast(r)
# definimos su resolucion
res(x) <- c(0.0005, 0.0005)
# hacemos un mapeo de los datos de menor resolucion a mayor utilizando diferentes metodos
xbilin <- resample(r, x, method="bilinear")
xcubic <- resample(r, x, method="cubic")
xcubicspline <- resample(r, x, method="cubicspline")
# graficamos el original y los 3 desagregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(xbilin)
plot(xcubic)
plot(xcubic)
pacman::p_load_gh("GIScience/openrouteservice-r")
reticulate::repl_python()
import pandas as pd
import pandas as pd
quit
a = 2
reticulate::repl_python()
a = 2
b = a
quit
a = 2
a = 2
reticulate::repl_python()
```{python}
quit
pacman::p_load(sf, tidyverse, sfnetworks, openrouteservice, terra, leaflet)
pacman::p_load(sf, tidyverse, sfnetworks, openrouteservice, terra, leaflet)
# cargamos un shape de poligonos
nc <- st_read(system.file("shape/nc.shp", package="sf"))
plot(nc)
# extramos la geometria
nc_g <- st_geometry(nc)
# dibujamos la primera geometria
plot(nc_g[1], lwd = 3)
# dibujamos la primera geometria
plot(nc_g[1], lwd = 1)
# dibujamos la primera geometria
plot(nc_g[1], lwd = 3)
plot(st_simplify(nc_g[1], dTolerance = 1e3), add=TRUE, border="red") # la simplificacion con umbral de 1000m
plot(st_simplify(nc_g[1], dTolerance = 5e3), add=TRUE, border="green") # 5000m
? st_simplify
# generamos poligono
pol <- st_polygon(list(rbind(c(0,0),c(1,0),c(1,1),c(0,1),c(0,0))))
plot(pol)
# segmentamos poligono con parametro de distancia 0.3
pol.seg <- st_segmentize(pol, 0.3)
# dibujamos resultados
plot(pol.seg, col = 'grey')
points(pol.seg[[1]])
# generamos linea
ls <- st_linestring(rbind(c(0,0),c(1,0),c(2,1),c(3,1)))
# segmentamos lineas
ls.seg <- st_segmentize(ls, 0.3)
# dibujamos resultados
plot(ls)
points(ls.seg)
# creamos lineas
lines <- st_multilinestring(list(
cbind(c(0, 1), c(1, 1.05)),
cbind(c(0, 1), c(0, -.05)),
cbind(c(1, .95, 1), c(1.05, .5, -.05))
))
# visualizamos
plot(lines, lwd=2, col='blue')
# creamos polinono
poly <- st_polygon(list(cbind(c(0, 0, 1, 1, 0), c(0, 1, 1, 0, 0))))
plot(poly, add=TRUE, pch = 2)
# acoplamos poligono a lineas
snapped <- st_snap(poly, lines, tolerance=.1)
# agregamos al grafico
plot(snapped, col='red', add=TRUE, alpha=0.5)
? st_snap
# creamos multilinea
mls <- st_multilinestring(list(matrix(c(0,0,0,1,1,1,0,0), 4 ,2,byrow=TRUE)))
# poligonizamos
st_polygonize(st_sfc(mls))
# visualizamos
plot(mls)
plot(st_polygonize(st_sfc(mls)), add=TRUE)
? st_triangulate
# triangulizamos la primera geometria del shape
triang <- st_triangulate(nc_g[1])
# dibujamos forma original y triangulos encima
plot(nc_g[1], col="black")
plot(triang, col=NULL, border="white", add=TRUE)
# creamos polignos de voronoi sobre la misma geometria de antes
voron <- st_voronoi(nc_g[1])
# repetimos el grafico
plot(nc_g[1], col="black")
plot(voron, col=NULL, border="white", add=TRUE)
voron
triang
? as_sfnetwork
? roxel
# obtenemos red de roxel, disponible en la libreria
net <- as_sfnetwork(roxel, directed = FALSE)
plot(net)
# utilizamos funcion para encontrar ruta entre nodos 1 y 9
path <- igraph::shortest_paths(net, 1, 9)
# obtenemos red de roxel, disponible en la libreria
net <- as_sfnetwork(roxel, directed = FALSE)$vpath
# obtenemos red de roxel, disponible en la libreria
net <- as_sfnetwork(roxel, directed = FALSE)$vpath[[1]]
# utilizamos funcion para encontrar ruta entre nodos 1 y 9
path <- igraph::shortest_paths(net, 1, 9)$vpath
# obtenemos red de roxel, disponible en la libreria
net <- as_sfnetwork(roxel, directed = FALSE)
# utilizamos funcion para encontrar ruta entre nodos 1 y 9
path <- igraph::shortest_paths(net, 1, 9)$vpath
# utilizamos funcion para encontrar ruta entre nodos 1 y 9
path <- igraph::shortest_paths(net, 1, 9)$vpath[[1]]
path
# extraemos del objeto net los puntos del camino mas corto
path_net <- st_geometry(net)[path %>% as.numeric()] %>%
st_as_sf("POINT")
path_net
net
path_net <- st_geometry(net)
st_geometry(net)[1]
st_geometry(net)[1,2]
path_net <- st_geometry(net)[c(1,2)]
path_net
path
path %>% as.numeric()
path_net <- st_geometry(net)[path %>% as.numeric()]
class(path)
as.numeric(path)
path_net <- st_geometry(net)[as.numeric(path)]
class(path_net)
# extraemos del objeto net los puntos del camino mas corto
path_net <- st_geometry(net)[path %>% as.numeric()] %>%
st_as_sf("POINT")
path_net
# agregamos puntos al mapa, de color rojo
plot(path_net, add=TRUE, col="red", lwd  = 8)
# cargamos ruta de cerro el plomo
plomo <- read_rds("data/ruta_plomo.rds")
# cargamos ruta de cerro el plomo
plomo <- read_rds("data/ruta_plomo.rds")
View(plomo)
# calculamos las metricas de distancia, diferencia de altitud de cada medicion
# calculamos la velocidad segun impedancia de toble, y luego la duracion
plomo <- plomo %>%
mutate(slope = pmin(0.4, pmax(-0.4,tan(grade_smooth/360*2*pi))),
tobler_speed = tobler_impedance(slope),
delta_distance = c(0,diff(distance)),
duration = (delta_distance)/tobler_speed) %>%
filter(delta_distance > 0)
# creamos funcion con impedancia segun regla de Tobler
tobler_impedance <- function(slope){
w <- 6*exp(-3.5*abs(slope + 0.05))
return(w)
}
# calculamos las metricas de distancia, diferencia de altitud de cada medicion
# calculamos la velocidad segun impedancia de toble, y luego la duracion
plomo <- plomo %>%
mutate(slope = pmin(0.4, pmax(-0.4,tan(grade_smooth/360*2*pi))),
tobler_speed = tobler_impedance(slope),
delta_distance = c(0,diff(distance)),
duration = (delta_distance)/tobler_speed) %>%
filter(delta_distance > 0)
# calculamos la diferencia entre medicion real y calculada
sum(plomo$duration)
max(plomo$time) / 3600
# para utilizar la libreria debemos obtener una llave a su API
# esta es mi llave, deberian obtener las suyas en la pagina para que no colapse
# https://openrouteservice.org/dev/#/signup
ors_api_key("5b3ce3597851110001cf6248db68c78edc7b41538810b09141f8cb60")
? ors_isochrones
ors_profile()
# utilizamos la funcion isochrones para calcular las isocronas de la coordenada a 20 minutos
drivetime <- ors_isochrones(
# definimos punto de inicio
locations = c(-70.51, -33.49),
# usamos perfil de ciclista
profile = "cycling-mountain",
# 20 minutos
range = 20*60,
# devuelve un objeto sf
output = "sf"
)
leaflet() %>%
addProviderTiles("OpenStreetMap") %>%
addAwesomeMarkers(
lat = -33.49,
lng = -70.51,
label = "UAI") %>%
addPolygons(data = drivetime)
# utilizamos la funcion isochrones para calcular las isocronas de la coordenada a 20 minutos
drivetime20 <- ors_isochrones(
# definimos punto de inicio
locations = c(-70.51, -33.49),
# usamos perfil de ciclista
profile = "cycling-mountain",
# 20 minutos
range = 20*60,
# devuelve un objeto sf
output = "sf"
)
drivetime15 <- ors_isochrones(
# definimos punto de inicio
locations = c(-70.51, -33.49),
# usamos perfil de ciclista
profile = "cycling-mountain",
# 20 minutos
range = 15*60,
# devuelve un objeto sf
output = "sf"
)
drivetime10 <- ors_isochrones(
# definimos punto de inicio
locations = c(-70.51, -33.49),
# usamos perfil de ciclista
profile = "cycling-mountain",
# 20 minutos
range = 10*60,
# devuelve un objeto sf
output = "sf"
)
# creamos mapa dinamico para visualizarlo
leaflet() %>%
addProviderTiles("OpenStreetMap") %>%
addAwesomeMarkers(
lat = -33.49,
lng = -70.51,
label = "UAI") %>%
addPolygons(data = drivetime20) %>%
addPolygons(data = drivetime15, col = "red") %>%
addPolygons(data = drivetime10, col = "green")
# identificamos un objeto raster de la libreria terra
f <- system.file("ex/elev.tif", package="terra")
# lo almacenamos como raster
r <- rast(f)
# exploramos su resolucion
res(r)
plot(r)
# disminuimos la resolucion utilizando diferentes funciones de agregacion
rmean <- aggregate(r, c(4,5), fun=mean)
rmin <- aggregate(r, c(4,5), fun=min)
rmax <- aggregate(r, c(4,5), fun=max)
# validamos resolucion
res(rmin)
# graficamos original y 3 agregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(rmean)
plot(rmin)
plot(rmax)
# graficamos original y 3 agregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(rmean)
plot(rmin)
plot(rmax)
plot(r)
# creamos un raster vacio en funcion de r
x <- rast(r)
res(r)
# definimos su resolucion
res(x) <- c(0.0005, 0.0005)
# hacemos un mapeo de los datos de menor resolucion a mayor utilizando diferentes metodos
xbilin <- resample(r, x, method="bilinear")
xcubic <- resample(r, x, method="cubic")
xcubicspline <- resample(r, x, method="cubicspline")
# graficamos el original y los 3 desagregaciones
par(mfrow=c(2,2), mar = c(0,0,1,0))
plot(r)
plot(xbilin)
plot(xcubic)
plot(xcubic)
# Leer Imagen satelital ---------------------------------------------------
library(raster)
LC <- brick("data/OLI_LC.tif")
LC
names(LC) <- c("aerosol","blue", "green", "red", "nir", "swir1", "swir2", "tir1" )
### latlon Utilizado a escala mundial
crs_latlon <- "+proj=longlat +datum=WGS84 +no_defs"
### utm utilizado a nivel regional (depende de la zona y hemisferio)
crs_utm <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
# Reproyección de Imagen Satelital ----------------------------------------
LC_ll <- projectRaster(LC, crs = crs_latlon)
# Color Natural
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "lin")
# plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "hist")
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "hist")
ext <- extent(c(350638, 358235,  6299157, 6304228))
# class(ext)
LC_crop <- crop(x = LC, y = ext, snap="out")
plotRGB(LC_crop, r = 4, g = 3, b = 2, stretch = "lin")
plotRGB(LC, r = 7, g = 6, b = 4, stretch = "lin")
# Las Condes: Infrarojo (5,4,3)
plotRGB(LC, r = 5, g = 4, b = 3, stretch = "lin")
# Las Condes: Agricultura (6,5,2)
plotRGB(LC, r = 6, g = 5, b = 2, stretch = "lin")
#NDVI(img, red, NIR)
NDVI <- function(img, r, n) {
br <- img[[r]]
bn <- img[[n]]
vi <- (bn - br) / (bn + br)
return(vi)
}
NDVI_lc <- NDVI(LC, 4, 5)
plot(NDVI_lc , main = "NDVI Las Condes")
hist(NDVI_lc, col="springgreen4", main="Histograma NDVI Las Condes",
ylab="Numero de Pixeles", xlab="valor NDVI")
corte_eq_menor<- function(value) {
function(x){ifelse(x <= value,NA, x)}
}
vegetacion <- calc(NDVI_lc, fun = corte_eq_menor(value = 0.3))
plot(vegetacion)
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))( 200 )
plot(vegetacion , main = "NDVI Vegetación Alta", col = pal_green)
## agregar Las polígono de Las Condes
LasCondes <- sf::st_read("../data/shape/LasCondes.shp")
plot(LasCondes$geometry, add = T, )
## agregar Las polígono de Las Condes
LasCondes <- sf::st_read("data/LasCondes.shp")
plot(LasCondes$geometry, add = T, )
suppressPackageStartupMessages(library(mapview))
mview <- mapview(LasCondes, color = "#05A39B", alpha.region =0)+
viewRGB(LC, r = 4, g = 3, b = 2, na.color = "transparent")+
mapview(vegetacion, na.color = "transparent") +
mapview(NDVI_lc, na.color = "transparent")
mview
mapshot(x = mview, url = "mapa_veg.html")
mview <- mapview(LasCondes, color = "#05A39B", alpha.region =0)+
viewRGB(LC, r = 4, g = 3, b = 2, na.color = "transparent")+
mapview(vegetacion, na.color = "transparent")
mview
mapshot(x = mview, url = "mapa_veg.html")
pacman::p_load(raster, mapview)
# cargo imagen satelital de las condes
LC <- brick("data/OLI_LC.tif")
LC
# asigno nombres a las bandas
names(LC) <- c("aerosol","blue", "green", "red", "nir", "swir1", "swir2", "tir1" )
LC_ll <- projectRaster(LC, crs = crs_utm)
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "lin")
pacman::p_load(raster, mapview)
# cargo imagen satelital de las condes
LC <- brick("data/OLI_LC.tif")
LC
# asigno nombres a las bandas
names(LC) <- c("aerosol","blue", "green", "red", "nir", "swir1", "swir2", "tir1" )
### utm utilizado a nivel regional (depende de la zona y hemisferio)
crs_utm <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
LC_ll <- projectRaster(LC, crs = crs_utm)
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "lin")
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "hist")
? plotRGB
# Color Natural
plotRGB(LC_ll, r = 4, g = 3, b = 2)
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "lin")
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "hist")
# Color Natural
plotRGB(LC_ll, r = 4, g = 3, b = 2)
# Color Natural con contraste de quiebres naturales
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "hist")
# Color Natural con contraste lineal
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "lin")
# definimos fronteras (extent)
ext <- extent(c(350638, 358235,  6299157, 6304228))
# recortamos
LC_crop <- crop(x = LC, y = ext, snap="out")
# visualizamos
plotRGB(LC_crop, r = 4, g = 3, b = 2, stretch = "lin")
## agregar los polígonos de Las Condes
LasCondes <- sf::st_read("data/LasCondes.shp")
plot(LasCondes$geometry, add = T, )
plotRGB(LC, r = 7, g = 6, b = 4, stretch = "lin")
# Infrarojo (5,4,3)
plotRGB(LC, r = 5, g = 4, b = 3, stretch = "lin")
# Agricultura (6,5,2)
plotRGB(LC, r = 6, g = 5, b = 2, stretch = "lin")
# Penetración de la Radiación en la Atmósfera (7,6,5)
plotRGB(LC, r = 7, g = 6, b = 5, stretch = "lin")
# Uso del Suelo / Masas de Agua (5,6,4)
plotRGB(LC, r = 5, g = 6, b = 4, stretch = "lin")
# Infrarojo de Onda Corta (7,5,4)
plotRGB(LC, r = 7, g = 5, b = 4, stretch = "lin")
# Análisis de Vegetación (6,5,4)
plotRGB(LC, r = 6, g = 5, b = 4, stretch = "lin")
# Análisis de Vegetación Sana (5,6,2)
plotRGB(LC, r = 5, g = 6, b = 2, stretch = "lin")
LC[[4]]
ndvi <- (LC[[4]] - LC[[5]]) / (LC[[4]] + LC[[5]])
plot(ndvi , main = "NDVI Las Condes")
hist(NDVI_lc, col="springgreen4", main="Histograma NDVI Las Condes",
ylab="Numero de Pixeles", xlab="valor NDVI")
hist(ndvi, col="springgreen4", main="Histograma NDVI Las Condes",
ylab="Numero de Pixeles", xlab="valor NDVI")
hist(ndvi, col="springgreen4")
? ndvi
? calc
ifelse(ndvi <= 0.3, NA, ndvi)
vegetacion <- calc(NDVI_lc, fun = function(x) ifelse(x <= 0.3, NA, x))
plot(vegetacion)
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))( 200 )
plot(vegetacion , main = "NDVI Vegetación Alta", col = pal_green)
# extraemos zonas con ndvi alto
vegetacion <- calc(ndvi, fun = function(x) ifelse(x <= 0.3, NA, x))
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))( 200 )
plot(vegetacion , main = "NDVI Vegetación Alta", col = pal_green)
# indice normalizado de vegetacion
ndvi <- (LC[[4]] - LC[[5]]) / (LC[[4]] + LC[[5]])
# dibujamos el nvdi
plot(ndvi , main = "NDVI Las Condes")
# indice normalizado de vegetacion
ndvi <- (LC[[5]] - LC[[4]]) / (LC[[4]] + LC[[5]])
# dibujamos el nvdi
plot(ndvi , main = "NDVI Las Condes")
# extraemos zonas con ndvi alto
vegetacion <- calc(ndvi, fun = function(x) ifelse(x <= 0.3, NA, x))
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))( 200 )
plot(vegetacion , main = "NDVI Vegetación Alta", col = pal_green)
## agregar los polígonos de Las Condes
LasCondes <- sf::st_read("data/LasCondes.shp")
plot(LasCondes$geometry, add = T, )
mview <- mapview(LasCondes, color = "#05A39B", alpha.region =0)+
viewRGB(LC, r = 4, g = 3, b = 2, na.color = "transparent")+
mapview(vegetacion, na.color = "transparent")
mview
? mapview
mview <- mapview(LasCondes, color = "#05A39B", alpha.region =0)+
viewRGB(LC, r = 4, g = 3, b = 2, na.color = "transparent")+
mapview(vegetacion, na.color = "transparent", col.regions=brewer.pal(9, "YlGn"))
mview
mview <- mapview(LasCondes, color = "#05A39B", alpha.region =0)+
viewRGB(LC, r = 4, g = 3, b = 2, na.color = "transparent")+
mapview(vegetacion, na.color = "transparent", col.regions=pal_green)
mview
