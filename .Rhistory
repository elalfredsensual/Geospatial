mview <- mapview(LasCondes, color = "#05A39B", alpha.region =0)+
viewRGB(LC, r = 4, g = 3, b = 2, na.color = "transparent") +
mapview(vegetacion_poly, na.color = "transparent", col.regions = pal_green)
mview
pacman::p_load(raster, mapview, sf, sfheaders)
pacman::p_load(raster, mapview, sf)
# Cargamos imagen satelital de las condes ----
LC <- brick("data/OLI_LC.tif")
LC
# asigno nombres a las bandas
names(LC) <- c("aerosol","blue", "green", "red", "nir", "swir1", "swir2", "tir1" )
### utm utilizado a nivel regional (depende de la zona y hemisferio)
crs_utm <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
# Reproyección de Imagen
LC_ll <- projectRaster(LC, crs = crs_utm)
# Color Natural
plotRGB(LC_ll, r = 4, g = 3, b = 2)
# Color Natural con contraste lineal
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "lin")
# Color Natural con contraste de quiebres naturales
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "hist")
# definimos fronteras (extent)
ext <- extent(c(350638, 358235,  6299157, 6304228))
# recortamos
LC_crop <- crop(x = LC, y = ext, snap="out")
# visualizamos
plotRGB(LC_crop, r = 4, g = 3, b = 2, stretch = "lin")
# Infrarojo (5,4,3)
plotRGB(LC, r = 5, g = 4, b = 3, stretch = "lin")
# Agricultura (6,5,2)
plotRGB(LC, r = 6, g = 5, b = 2, stretch = "lin")
# Penetración de la Radiación en la Atmósfera (7,6,5)
plotRGB(LC, r = 7, g = 6, b = 5, stretch = "lin")
# Uso del Suelo / Masas de Agua (5,6,4)
plotRGB(LC, r = 5, g = 6, b = 4, stretch = "lin")
# Infrarojo de Onda Corta (7,5,4)
plotRGB(LC, r = 7, g = 5, b = 4, stretch = "lin")
# Análisis de Vegetación (6,5,4)
plotRGB(LC, r = 6, g = 5, b = 4, stretch = "lin")
# Análisis de Vegetación Sana (5,6,2)
plotRGB(LC, r = 5, g = 6, b = 2, stretch = "lin")
# normalizamos los valores del canal 5 (x-mean)/sd
infrared <- scale(LC[[5]])
# dibujamos el infrarojo
plot(infrared)
# extraemos zonas con infrarojo alto, que aproximan a la vegetacion
vegetacion <- calc(infrared, fun = function(x) ifelse(x <= 3, NA, x))
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))
plot(vegetacion , col = pal_green( 200 ))
# pasamos pixeles a poligonos
poligonos_infrarojo <- rasterToPolygons(vegetacion, digits = 16) %>% st_as_sf()
plot(poligonos_infrarojo, pal = pal_green)
# veamos que pasa al unirlos
merged_poligonos_infrarojo <- poligonos_infrarojo  %>%
st_union() %>% # unimos vecinos
st_cast("POLYGON")  # aislamos los poligonos resultantes
plot(merged_poligonos_infrarojo, pal = pal_green)
# extraemos los valores del raster original sobre cada poligono resultante y lo guardamos en un df
vegetacion_poly <- data.frame(vegetacion = raster::extract(vegetacion,
st_as_sf(merged_poligonos_infrarojo),
fun=mean))
# le asignamos al df las geometrias de los poligonos
st_geometry(vegetacion_poly) <- st_sfc(merged_poligonos_infrarojo)
# visualizamos
plot(vegetacion_poly, pal = pal_green)
# agregar la frontera de Las Condes
LasCondes <- sf::st_read("data/LasCondes.shp")
plot(LasCondes$geometry)
plot(vegetacion_poly, pal = pal_green, add = TRUE)
# visualizamos en mapa interactivo
mview <- mapview(LasCondes, color = "#05A39B", alpha.region =0)+
viewRGB(LC, r = 4, g = 3, b = 2, na.color = "transparent") +
mapview(vegetacion_poly, na.color = "transparent", col.regions = pal_green)
mview
pacman::p_load(raster, mapview, sf)
# Cargamos imagen satelital de las condes ----
LC <- brick("data/OLI_LC.tif")
LC
# Número de bandas asignado a la Imagen OLI Landsat
#
# - aerosol = 1
# - blue    = 2
# - green   = 3
# - red     = 4
# - nir     = 5
# - swir1   = 6
# - swir2   = 7
# - thermal  = 8
# asigno nombres a las bandas
names(LC) <- c("aerosol","blue", "green", "red", "nir", "swir1", "swir2", "tir1" )
### utm utilizado a nivel regional (depende de la zona y hemisferio)
crs_utm <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
# Reproyección de Imagen
LC_ll <- projectRaster(LC, crs = crs_utm)
# Mapeamos la imagen ----
# Color Natural
plotRGB(LC_ll, r = 4, g = 3, b = 2)
# Color Natural con contraste lineal
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "lin")
# Color Natural con contraste de quiebres naturales
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "hist")
# recortamos extension de la imagen
# definimos fronteras (extent)
ext <- extent(c(350638, 358235,  6299157, 6304228))
# recortamos
LC_crop <- crop(x = LC, y = ext, snap="out")
# visualizamos
plotRGB(LC_crop, r = 4, g = 3, b = 2, stretch = "lin")
# Visualizamos falso color ----
# Infrarojo (5,4,3)
plotRGB(LC, r = 5, g = 4, b = 3, stretch = "lin")
# Agricultura (6,5,2)
plotRGB(LC, r = 6, g = 5, b = 2, stretch = "lin")
# Penetración de la Radiación en la Atmósfera (7,6,5)
plotRGB(LC, r = 7, g = 6, b = 5, stretch = "lin")
# Uso del Suelo / Masas de Agua (5,6,4)
plotRGB(LC, r = 5, g = 6, b = 4, stretch = "lin")
# Infrarojo de Onda Corta (7,5,4)
plotRGB(LC, r = 7, g = 5, b = 4, stretch = "lin")
# Análisis de Vegetación (6,5,4)
plotRGB(LC, r = 6, g = 5, b = 4, stretch = "lin")
# Análisis de Vegetación Sana (5,6,2)
plotRGB(LC, r = 5, g = 6, b = 2, stretch = "lin")
# Cargamos imagen satelital de las condes ----
LC <- brick("data/OLI_LC.tif")
pacman::p_load(raster, mapview, sf)
? brick
# Cargamos imagen satelital de las condes ----
LC <- brick("data/OLI_LC.tif")
LC
449 * 562
names(LC)
# asigno nombres a las bandas
names(LC) <- c("aerosol","blue", "green", "red", "nir", "swir1", "swir2", "tir1" )
### utm utilizado a nivel regional (depende de la zona y hemisferio)
crs_utm <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
# Reproyección de Imagen
LC_ll <- projectRaster(LC, crs = crs_utm)
? plotRGB
# Color Natural
plotRGB(LC_ll, r = 4, g = 3, b = 2)
# Color Natural con contraste lineal
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "lin")
# Color Natural con contraste de quiebres naturales
plotRGB(LC_ll, r = 4, g = 3, b = 2, stretch = "hist")
# Color Natural
plotRGB(LC_ll)
# definimos fronteras (extent)
ext <- extent(c(350638, 358235,  6299157, 6304228))
# recortamos
LC_crop <- crop(x = LC, y = ext, snap="out")
# visualizamos
plotRGB(LC_crop, r = 4, g = 3, b = 2, stretch = "lin")
# Infrarojo (5,4,3)
plotRGB(LC, r = 5, g = 4, b = 3, stretch = "lin")
# Agricultura (6,5,2)
plotRGB(LC, r = 6, g = 5, b = 2, stretch = "lin")
# Penetración de la Radiación en la Atmósfera (7,6,5)
plotRGB(LC, r = 7, g = 6, b = 5, stretch = "lin")
# Uso del Suelo / Masas de Agua (5,6,4)
plotRGB(LC, r = 5, g = 6, b = 4, stretch = "lin")
# Infrarojo de Onda Corta (7,5,4)
plotRGB(LC, r = 7, g = 5, b = 4, stretch = "lin")
# Análisis de Vegetación (6,5,4)
plotRGB(LC, r = 6, g = 5, b = 4, stretch = "lin")
# Análisis de Vegetación Sana (5,6,2)
plotRGB(LC, r = 5, g = 6, b = 2, stretch = "lin")
LC[[5]]
# normalizamos los valores del canal 5 (x-mean)/sd
infrared <- scale(LC[[5]])
infrared
# dibujamos el infrarojo
plot(infrared)
? calc
# extraemos zonas con infrarojo alto, que aproximan a la vegetacion
vegetacion <- calc(infrared, fun = function(x) ifelse(x <= 3, NA, x))
vegetacion
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))
plot(vegetacion , col = pal_green( 200 ))
# extraemos zonas con infrarojo alto, que aproximan a la vegetacion
vegetacion <- calc(infrared, fun = function(x) ifelse(x <= 2, NA, x))
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))
plot(vegetacion , col = pal_green( 200 ))
# extraemos zonas con infrarojo alto, que aproximan a la vegetacion
vegetacion <- calc(infrared, fun = function(x) ifelse(x <= 1, NA, x))
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))
plot(vegetacion , col = pal_green( 200 ))
# extraemos zonas con infrarojo alto, que aproximan a la vegetacion
vegetacion <- calc(infrared, fun = function(x) ifelse(x <= 3, NA, x))
pal_green <- colorRampPalette(c("green","springgreen4", "darkgreen"))
plot(vegetacion , col = pal_green( 200 ))
# pasamos pixeles a poligonos
poligonos_infrarojo <- rasterToPolygons(vegetacion, digits = 16) %>% st_as_sf()
View(poligonos_infrarojo)
plot(poligonos_infrarojo, pal = pal_green)
# veamos que pasa al unirlos
merged_poligonos_infrarojo <- poligonos_infrarojo  %>%
st_union() %>% # unimos vecinos
st_cast("POLYGON")  # aislamos los poligonos resultantes
plot(merged_poligonos_infrarojo, pal = pal_green)
# extraemos los valores del raster original sobre cada poligono resultante y lo guardamos en un df
vegetacion_poly <- data.frame(vegetacion = raster::extract(vegetacion,
st_as_sf(merged_poligonos_infrarojo),
fun=mean))
View(vegetacion_poly)
st_geometry(vegetacion_poly)
# le asignamos al df las geometrias de los poligonos
st_geometry(vegetacion_poly) <- st_sfc(merged_poligonos_infrarojo)
# visualizamos
plot(vegetacion_poly, pal = pal_green)
# agregar la frontera de Las Condes
LasCondes <- sf::st_read("data/LasCondes.shp")
plot(LasCondes$geometry)
plot(vegetacion_poly, pal = pal_green, add = TRUE)
# visualizamos en mapa interactivo
mview <- mapview(LasCondes, color = "#05A39B", alpha.region =0) +
viewRGB(LC, r = 4, g = 3, b = 2, na.color = "transparent") +
mapview(vegetacion_poly, na.color = "transparent", col.regions = pal_green)
mview
# guardamos el mapa como pagina html
mapshot(x = mview, url = "mapa_veg.html")
pacman::p_load(tidyverse, rgee)
ee_Initialize(drive = T)
ee_check()
ee_install()
pacman::p_load(tidyverse, rgee)
ee_Initialize(drive = T)
manquehue <- c(-70.5801, -33.3521)
manquehue <- c(-70.5801, -33.3521)
# identifico posibles fechas de imagenes del LS8
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate('2018-01-08','2018-10-08')$
filterBounds(ee$Geometry$Point(coords = punto))$
filterMetadata('CLOUD_COVER','less_than', 10)
# identifico posibles fechas de imagenes del LS8
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate('2018-01-08','2018-10-08')$
filterBounds(ee$Geometry$Point(coords = manquehue))$
filterMetadata('CLOUD_COVER','less_than', 10)
# ordeno las fechas
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
# extraigo la primera
escena <- df_disponible$id[1]
# capturo el objeto correspondiente a esa fecha
landsat <- ee$Image(escena)
landsat$bandNames
# creo objeto espacial con punto
sf_point <- st_point(x = manquehue, dim = "XYZ")
pacman::p_load(tidyverse, rgee, sf)
# creo objeto espacial con punto
sf_point <- st_point(x = manquehue, dim = "XYZ")
# genero un buffer alrededor
point_buff <- st_buffer(sf_point, dist = 0.1)
plot(point_buff)
# extraigo coordenadas del poligono buffer
locations <- point_buff[[1]] %>% as.data.frame()
# defino la zona de interes como objeto ee
roi <- point_buff %>%  sf_as_ee()
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = landsat,
region = roi$bounds(),
scale = 30)
rgb_bands <- landsat$select(c("B1", "B2", "B3", "B4", "B5", "B6"))
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = landsat,
region = roi$bounds(),
scale = 30)
rgb_bands <- landsat$select(c("B2", "B3", "B4", "B5", "B6"))
rgb_bands <- landsat$select(c("B1", "B2", "B3", "B4", "B5", "B6"))
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = rgb_bands,
region = roi$bounds(),
scale = 30)
l8_bands <- landsat$select(c("B1", "B2", "B3", "B4", "B5", "B6", "B7", "B9"))
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = l8_bands,
region = roi$bounds(),
scale = 30)
plot(l8_img)
plot(l8_img$B1)
l8_img$B1
pacman::p_load(tidyverse, rgee, sf, raster)
plot(l8_img$B1)
plot(l8_img)
l8_bands <- landsat$select(c("B1", "B2", "B3", "B4", "B5", "B6", "B7", "B9", "B8"))
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = l8_bands,
region = roi$bounds(),
scale = 30)
NVDI <- function(rasterstack_l8){
return((rasterstack_l8$B1 - rasterstack_l8$b4)/rasterstack_l8$B6 +1)
}
NVDI(l8_img)
NVDI <- function(rasterstack_l8){
return((rasterstack_l8$B1 - rasterstack_l8$B4)/rasterstack_l8$B6 +1)
}
NVDI(l8_img)
plot(NVDI(l8_img))
# defino una region de interes
manquehue <-
c(-70.5801, -33.3521) %>%
st_point(dim = "XYZ")
# defino una region de interes
manquehue <-
c(-70.5801, -33.3521) %>%
st_point(dim = "XYZ") %>%
st_buffer(dist = 0.1)
# defino una region de interes
roi <-
c(-70.5801, -33.3521) %>%  # cerro manquehue
st_point(dim = "XYZ") %>%
st_buffer(dist = 0.1) %>%
sf_as_ee()
# identifico posibles fechas de imagenes del LS8
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate('2018-01-08','2018-10-08')$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 10)
# ordeno las fechas
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
# extraigo la primera
escena <- df_disponible$id[1]
# capturo el objeto correspondiente a esa fecha
landsat <- ee$Image(escena)
l8_bands <- ee$Image(escena)$select(c("B1", "B2", "B3", "B4", "B5", "B6", "B7", "B9"))
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = l8_bands,
region = roi$bounds(),
scale = 30)
# creo funcion
NVDI <- function(rasterstack_l8){
return((rasterstack_l8$B1 - rasterstack_l8$B4)/rasterstack_l8$B6 +1)
}
plot(NVDI(l8_img))
# creo funcion
NVDI <- function(rasterstack_l8){
return((rasterstack_l8$B5 - rasterstack_l8$B4)/(rasterstack_l8$B5 + rasterstack_l8$B4))
}
plot(NVDI(l8_img))
escena
ee_get_date_ic(disponible)%>%
arrange(time_start)
return((rasterstack_l8$B5 - rasterstack_l8$B3)/(rasterstack_l8$B5 + rasterstack_l8$B3))
GNVDI <- function(rasterstack_l8){
return((rasterstack_l8$B5 - rasterstack_l8$B3)/(rasterstack_l8$B5 + rasterstack_l8$B3))
}
plot(GNVDI(l8_img))
# identifico posibles fechas de imagenes del LS8
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate('2018-01-08','2018-10-08')$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 5)
# ordeno las fechas
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
# extraigo la primera
escena <- df_disponible$id[1]
# defino las bandas que me interesa extraer
l8_bands <- ee$Image(escena)$select(c("B1", "B2", "B3", "B4",
"B5", "B6", "B7", "B9"))
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = l8_bands,
region = roi$bounds(),
scale = 30)
# creo funcion
NVDI <- function(rasterstack_l8){
return((rasterstack_l8$B5 - rasterstack_l8$B4)/(rasterstack_l8$B5 + rasterstack_l8$B4))
}
plot(NVDI(l8_img))
GNVDI <- function(rasterstack_l8){
return((rasterstack_l8$B5 - rasterstack_l8$B3)/(rasterstack_l8$B5 + rasterstack_l8$B3))
}
plot(GNVDI(l8_img))
'2013-11-01'
paste0(anio,'-11-01')
anio = 2013
paste0(anio,'-11-01')
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-10'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 5)
pacman::p_load(tidyverse, rgee, sf, terra)
ee_Initialize(drive = T)
# defino una region de interes ----
roi <-
c(-70.915374, -33.8464671) %>%  # laguna aculeo
st_point(dim = "XYZ") %>%
st_buffer(dist = 0.1) %>%
sf_as_ee()
pacman::p_load(tidyverse, rgee, sf, terra)
ee_Initialize(drive = T)
ee_install()
ee_clean_pyenv()
pacman::p_load(tidyverse, rgee, sf, terra)
ee_Initialize(drive = T)
pacman::p_load(tidyverse, rgee, sf, terra)
ee_install()
pacman::p_load(tidyverse, rgee, sf, terra)
ee_Initialize(drive = T)
ee_install_set_pyenv()
ee_check()
ee_install()
pacman::p_load(tidyverse, rgee, sf, terra)
ee_Initialize(drive = T)
ee_install()
reticulate::install_miniconda(force = TRUE)
ee_Initialize(drive = T)
ee_check()
pacman::p_load(tidyverse, rgee, sf, terra)
ee_Initialize(drive = T)
ee_check()
ee_install()
ee_clean_pyenv()
pacman::p_load(tidyverse, rgee, sf, terra)
ee_install()
pacman::p_load(tidyverse, rgee, sf, terra)
ee_check()
pacman::p_load(tidyverse, rgee, sf, terra)
ee_Initialize(drive = T)
# defino una region de interes ----
roi <-
c(-70.915374, -33.8464671) %>%  # laguna aculeo
st_point(dim = "XYZ") %>%
st_buffer(dist = 0.1) %>%
sf_as_ee()
anio <- 2013
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-10'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 5)
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
ee_get_date_ic(disponible)
paste0(anio,'-11-10')
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-10'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 10)
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-30'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 10)
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
# extraigo la primera
escena <- df_disponible$id[1]
# defino las bandas que me interesa extraer para el NDWI
l8_bands <- ee$Image(escena)$select(c("B2", "B3", "B4", "B5"))
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = l8_bands,
region = roi$bounds(),
scale = 30)
# llamo funciones
source("R/indices.R")
NDWI(l8_img)
plot(NDWI(l8_img))
agua <- calc(NDWI(l8_img), fun = function(x) ifelse(x <= 0.2, NA, x))
agua <- raster::calc(NDWI(l8_img), fun = function(x) ifelse(x <= 0.2, NA, x))
plot(agua)
plotRGB(l8_img, r=4, g=3, b=2, stretch = "lin")
plot(agua, add = TRUE)
plotRGB(l8_img, r=3, g=2, b=1, stretch = "lin")
plot(agua, add = TRUE)
png(file=paste0("aculeo_anio",anio,".png"), width=500, height=600)
plotRGB(l8_img, r=3, g=2, b=1, stretch = "lin")
plot(agua, add = TRUE)
dev.off()
# analisis aculeo en el tiempo
analisis_aculeo <- function(anio){
disponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$
filterDate(paste0(anio,'-11-01'),paste0(anio,'-11-30'))$
filterBounds(roi)$
filterMetadata('CLOUD_COVER','less_than', 10)
df_disponible <- ee_get_date_ic(disponible)%>%
arrange(time_start)
# extraigo la primera
escena <- df_disponible$id[1]
# defino las bandas que me interesa extraer para el NDWI
l8_bands <- ee$Image(escena)$select(c("B2", "B3", "B4", "B5"))
# B1: Aerosol, B2: Blue, B3: Green, B4: Red
# B5: NIR, B6: SWIR 1, B7: SWIR 2, B9: Cirrus
# extraigo imagenes satelitales
l8_img <- ee_as_raster(
image = l8_bands,
region = roi$bounds(),
scale = 30)
agua <- calc(NDWI(l8_img), fun = function(x) ifelse(x <= 0.2, NA, x))
png(file=paste0("aculeo_anio",anio,".png"), width=500, height=600)
plotRGB(l8_img, r=3, g=2, b=1, stretch = "lin")
plot(agua, add = TRUE)
dev.off()
}
2013:2022
purrr::map(2013:2022, analisis_aculeo)
# listo funciones
funs <- lsf.str()
pacman::p_load(tidyverse, rgee, sf, raster)
purrr::map(2013:2022, analisis_aculeo)
pacman::p_load(tidyverse, rgee, sf, raster)
ee_Initialize(drive = T)
